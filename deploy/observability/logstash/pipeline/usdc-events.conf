input {
  # Input for USDC event tracker application logs (JSON format)
  tcp {
    port => 5000
    codec => json_lines
  }
  
  # Input for file-based logs
  file {
    path => "/usr/share/filebeat/logs/*.log"
    start_position => "beginning"
    codec => json
  }
}

filter {
  # Parse timestamp if it exists
  if [@timestamp] {
    date {
      match => [ "@timestamp", "ISO8601" ]
      target => "@timestamp"
    }
  }
  
  # Add processing timestamp
  mutate {
    add_field => { "processed_at" => "%{+YYYY-MM-dd'T'HH:mm:ss.SSSZ}" }
  }
  
  # Enrich USDC transaction events
  if [component] == "tracker" and [event_type] == "blockchain_event" {
    mutate {
      add_tag => [ "usdc_transaction" ]
      add_field => { "event_category" => "blockchain" }
    }
    
    # Convert gas_used to number for analytics
    if [fields][gas_used] {
      mutate {
        convert => { "[fields][gas_used]" => "integer" }
      }
    }
    
    # Convert block_number to number
    if [fields][block_number] {
      mutate {
        convert => { "[fields][block_number]" => "integer" }
      }
    }
    
    # Add network information for filtering
    if [fields][event_type] == "Transfer" {
      mutate {
        add_tag => [ "usdc_transfer" ]
      }
    } else if [fields][event_type] == "Approval" {
      mutate {
        add_tag => [ "usdc_approval" ]
      }
    }
  }
  
  # Process block processing events
  if [component] == "tracker" and [event_type] == "block_processing" {
    mutate {
      add_tag => [ "block_processing" ]
      add_field => { "event_category" => "system" }
    }
    
    # Convert numeric fields
    if [fields][block_number] {
      mutate {
        convert => { "[fields][block_number]" => "integer" }
      }
    }
    
    if [fields][transaction_count] {
      mutate {
        convert => { "[fields][transaction_count]" => "integer" }
      }
    }
  }
  
  # Process sink operations
  if [component] and [component] =~ /.*sink.*/ and [event_type] == "sink_operation" {
    mutate {
      add_tag => [ "sink_operation" ]
      add_field => { "event_category" => "system" }
    }
    
    # Convert numeric fields
    if [fields][duration_ms] {
      mutate {
        convert => { "[fields][duration_ms]" => "integer" }
      }
    }
    
    if [fields][event_count] {
      mutate {
        convert => { "[fields][event_count]" => "integer" }
      }
    }
  }
  
  # Process connection events
  if [event_type] == "connection_established" {
    mutate {
      add_tag => [ "connection" ]
      add_field => { "event_category" => "system" }
    }
  }
  
  # Add geolocation for IP addresses (if available)
  # This would be useful for monitoring where transactions are coming from
  # if [client_ip] {
  #   geoip {
  #     source => "client_ip"
  #     target => "geoip"
  #   }
  # }
  
  # Calculate derived metrics
  if "usdc_transaction" in [tags] {
    # Add hour of day for time-based analytics
    ruby {
      code => "
        event.set('hour_of_day', Time.now.hour)
        event.set('day_of_week', Time.now.strftime('%A'))
      "
    }
  }
}

output {
  # Send to Elasticsearch with proper index patterns
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    
    # Dynamic index based on event type and date
    index => "usdc-logs-%{+YYYY.MM.dd}"
    
    # Use different indices for different event types
    if "usdc_transaction" in [tags] {
      elasticsearch {
        hosts => ["elasticsearch:9200"]
        index => "usdc-transactions-%{+YYYY.MM.dd}"
      }
    } else if "block_processing" in [tags] {
      elasticsearch {
        hosts => ["elasticsearch:9200"]
        index => "usdc-blocks-%{+YYYY.MM.dd}"
      }
    } else if "sink_operation" in [tags] {
      elasticsearch {
        hosts => ["elasticsearch:9200"]
        index => "usdc-sinks-%{+YYYY.MM.dd}"
      }
    }
  }
  
  # Debug output for development
  if [level] == "DEBUG" {
    stdout {
      codec => rubydebug
    }
  }
}